{"ast":null,"code":"import \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.function.name\";\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nimport { Observable, merge, asapScheduler } from 'rxjs';\nimport { debounceTime, filter, map, mergeMap, share, tap, throttleTime } from 'rxjs/operators';\nimport createLogicAction$ from './createLogicAction$';\nimport { identityFn } from './utils';\nimport createDispatch from './createDispatch';\nimport execProcessFn from './execProcessFn';\nimport createCancelled$ from './createCancelled$';\nimport createDepObject from './createDepObject';\nvar MATCH_ALL_TYPES = '*';\nexport default function logicWrapper(logic, store, deps, monitor$) {\n  var name = logic.name,\n      type = logic.type,\n      cancelType = logic.cancelType,\n      latest = logic.latest,\n      debounce = logic.debounce,\n      throttle = logic.throttle,\n      processFn = logic.process,\n      dispatchReturn = logic.processOptions.dispatchReturn;\n  var getState = store.getState; // cancel on cancelType or if take latest specified\n\n  var cancelTypes = [].concat(type && latest ? type : []).concat(cancelType || []);\n  return function wrappedLogic(actionIn$) {\n    // we want to share the same copy amongst all here\n    var action$ = actionIn$.pipe(share());\n    var cancel$ = cancelTypes.length ? action$.pipe(filter(function (action) {\n      return matchesType(cancelTypes, action.type);\n    })) : null;\n    var hasIntercept = logic.validate || logic.transform; // shortcut optimization if no intercept let action fall through\n    // and just exec the processFn\n\n    var mergeMapOrTap = hasIntercept ? mergeMap(function (action) {\n      return createLogicAction$({\n        action: action,\n        logic: logic,\n        store: store,\n        deps: deps,\n        cancel$: cancel$,\n        monitor$: monitor$,\n        action$: action$\n      });\n    }) : tap(function (action) {\n      // mimic the events as if went through createLogicAction$\n      // also in createLogicAction$\n      monitor$.next({\n        action: action,\n        name: name,\n        op: 'begin'\n      });\n      monitor$.next({\n        action: action,\n        nextAction: action,\n        name: name,\n        shouldProcess: true,\n        op: 'next'\n      });\n\n      var _createCancelled$ = createCancelled$({\n        action: action,\n        cancel$: cancel$,\n        monitor$: monitor$,\n        logic: logic\n      }),\n          cancelled$ = _createCancelled$.cancelled$,\n          setInterceptComplete = _createCancelled$.setInterceptComplete;\n\n      var _createDispatch = createDispatch({\n        action: action,\n        cancel$: cancel$,\n        cancelled$: cancelled$,\n        logic: logic,\n        monitor$: monitor$,\n        store: store\n      }),\n          dispatch = _createDispatch.dispatch,\n          dispatch$ = _createDispatch.dispatch$,\n          done = _createDispatch.done;\n\n      var ctx = {}; // no intercept, so empty ctx;\n\n      var depObj = createDepObject({\n        deps: deps,\n        cancelled$: cancelled$,\n        ctx: ctx,\n        getState: getState,\n        action: action,\n        action$: action$\n      });\n      asapScheduler.schedule(function () {\n        setInterceptComplete();\n        execProcessFn({\n          depObj: depObj,\n          dispatch: dispatch,\n          dispatch$: dispatch$,\n          dispatchReturn: dispatchReturn,\n          done: done,\n          name: name,\n          processFn: processFn\n        });\n      });\n    });\n    var matchingOps = [// operations to perform, falsey filtered out\n    filter(function (action) {\n      return matchesType(type, action.type);\n    }), debounce ? debounceTime(debounce) : null, throttle ? throttleTime(throttle) : null, mergeMapOrTap].filter(identityFn);\n    var matchingAction$ = action$.pipe.apply(action$, _toConsumableArray(matchingOps)); // shortcut optimization\n    // if type is match all '*', then no need to create other side of pipe\n\n    if (type === MATCH_ALL_TYPES) {\n      return matchingAction$;\n    } // types that don't match will bypass this logic\n\n\n    var nonMatchingAction$ = action$.pipe(filter(function (action) {\n      return !matchesType(type, action.type);\n    }));\n    return merge(nonMatchingAction$, matchingAction$);\n  };\n}\n\nfunction matchesType(tStrArrRe, type) {\n  /* istanbul ignore if  */\n  if (!tStrArrRe) {\n    return false;\n  } // nothing matches none\n\n\n  if (_typeof(tStrArrRe) === 'symbol') {\n    return tStrArrRe === type;\n  }\n\n  if (typeof tStrArrRe === 'string') {\n    return tStrArrRe === type || tStrArrRe === MATCH_ALL_TYPES;\n  }\n\n  if (Array.isArray(tStrArrRe)) {\n    return tStrArrRe.some(function (x) {\n      return matchesType(x, type);\n    });\n  } // else assume it is a RegExp\n\n\n  return tStrArrRe.test(type);\n}","map":{"version":3,"sources":["/Users/aaronkaspar/Desktop/Mexiko/Modules/DAW/VisualStudio/Flight-main/node_modules/redux-logic/build-es/logicWrapper.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Object","toString","call","Array","from","isArray","i","arr2","length","Observable","merge","asapScheduler","debounceTime","filter","map","mergeMap","share","tap","throttleTime","createLogicAction$","identityFn","createDispatch","execProcessFn","createCancelled$","createDepObject","MATCH_ALL_TYPES","logicWrapper","logic","store","deps","monitor$","name","type","cancelType","latest","debounce","throttle","processFn","process","dispatchReturn","processOptions","getState","cancelTypes","concat","wrappedLogic","actionIn$","action$","pipe","cancel$","action","matchesType","hasIntercept","validate","transform","mergeMapOrTap","next","op","nextAction","shouldProcess","_createCancelled$","cancelled$","setInterceptComplete","_createDispatch","dispatch","dispatch$","done","ctx","depObj","schedule","matchingOps","matchingAction$","apply","nonMatchingAction$","tStrArrRe","some","x","test"],"mappings":"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","sourcesContent":["import \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.function.name\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nimport { Observable, merge, asapScheduler } from 'rxjs';\nimport { debounceTime, filter, map, mergeMap, share, tap, throttleTime } from 'rxjs/operators';\nimport createLogicAction$ from './createLogicAction$';\nimport { identityFn } from './utils';\nimport createDispatch from './createDispatch';\nimport execProcessFn from './execProcessFn';\nimport createCancelled$ from './createCancelled$';\nimport createDepObject from './createDepObject';\nvar MATCH_ALL_TYPES = '*';\nexport default function logicWrapper(logic, store, deps, monitor$) {\n  var name = logic.name,\n      type = logic.type,\n      cancelType = logic.cancelType,\n      latest = logic.latest,\n      debounce = logic.debounce,\n      throttle = logic.throttle,\n      processFn = logic.process,\n      dispatchReturn = logic.processOptions.dispatchReturn;\n  var getState = store.getState; // cancel on cancelType or if take latest specified\n\n  var cancelTypes = [].concat(type && latest ? type : []).concat(cancelType || []);\n  return function wrappedLogic(actionIn$) {\n    // we want to share the same copy amongst all here\n    var action$ = actionIn$.pipe(share());\n    var cancel$ = cancelTypes.length ? action$.pipe(filter(function (action) {\n      return matchesType(cancelTypes, action.type);\n    })) : null;\n    var hasIntercept = logic.validate || logic.transform; // shortcut optimization if no intercept let action fall through\n    // and just exec the processFn\n\n    var mergeMapOrTap = hasIntercept ? mergeMap(function (action) {\n      return createLogicAction$({\n        action: action,\n        logic: logic,\n        store: store,\n        deps: deps,\n        cancel$: cancel$,\n        monitor$: monitor$,\n        action$: action$\n      });\n    }) : tap(function (action) {\n      // mimic the events as if went through createLogicAction$\n      // also in createLogicAction$\n      monitor$.next({\n        action: action,\n        name: name,\n        op: 'begin'\n      });\n      monitor$.next({\n        action: action,\n        nextAction: action,\n        name: name,\n        shouldProcess: true,\n        op: 'next'\n      });\n\n      var _createCancelled$ = createCancelled$({\n        action: action,\n        cancel$: cancel$,\n        monitor$: monitor$,\n        logic: logic\n      }),\n          cancelled$ = _createCancelled$.cancelled$,\n          setInterceptComplete = _createCancelled$.setInterceptComplete;\n\n      var _createDispatch = createDispatch({\n        action: action,\n        cancel$: cancel$,\n        cancelled$: cancelled$,\n        logic: logic,\n        monitor$: monitor$,\n        store: store\n      }),\n          dispatch = _createDispatch.dispatch,\n          dispatch$ = _createDispatch.dispatch$,\n          done = _createDispatch.done;\n\n      var ctx = {}; // no intercept, so empty ctx;\n\n      var depObj = createDepObject({\n        deps: deps,\n        cancelled$: cancelled$,\n        ctx: ctx,\n        getState: getState,\n        action: action,\n        action$: action$\n      });\n      asapScheduler.schedule(function () {\n        setInterceptComplete();\n        execProcessFn({\n          depObj: depObj,\n          dispatch: dispatch,\n          dispatch$: dispatch$,\n          dispatchReturn: dispatchReturn,\n          done: done,\n          name: name,\n          processFn: processFn\n        });\n      });\n    });\n    var matchingOps = [// operations to perform, falsey filtered out\n    filter(function (action) {\n      return matchesType(type, action.type);\n    }), debounce ? debounceTime(debounce) : null, throttle ? throttleTime(throttle) : null, mergeMapOrTap].filter(identityFn);\n    var matchingAction$ = action$.pipe.apply(action$, _toConsumableArray(matchingOps)); // shortcut optimization\n    // if type is match all '*', then no need to create other side of pipe\n\n    if (type === MATCH_ALL_TYPES) {\n      return matchingAction$;\n    } // types that don't match will bypass this logic\n\n\n    var nonMatchingAction$ = action$.pipe(filter(function (action) {\n      return !matchesType(type, action.type);\n    }));\n    return merge(nonMatchingAction$, matchingAction$);\n  };\n}\n\nfunction matchesType(tStrArrRe, type) {\n  /* istanbul ignore if  */\n  if (!tStrArrRe) {\n    return false;\n  } // nothing matches none\n\n\n  if (_typeof(tStrArrRe) === 'symbol') {\n    return tStrArrRe === type;\n  }\n\n  if (typeof tStrArrRe === 'string') {\n    return tStrArrRe === type || tStrArrRe === MATCH_ALL_TYPES;\n  }\n\n  if (Array.isArray(tStrArrRe)) {\n    return tStrArrRe.some(function (x) {\n      return matchesType(x, type);\n    });\n  } // else assume it is a RegExp\n\n\n  return tStrArrRe.test(type);\n}"]},"metadata":{},"sourceType":"module"}