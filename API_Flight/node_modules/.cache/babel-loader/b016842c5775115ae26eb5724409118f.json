{"ast":null,"code":"import \"core-js/modules/es6.array.iterator\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.function.name\";\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nimport isPromise from 'is-promise';\nimport { Observable, Subject } from 'rxjs';\nimport { take, takeUntil } from 'rxjs/operators';\nimport { identityFn, wrapActionForIntercept } from './utils';\nimport createDepObject from './createDepObject';\nimport execProcessFn from './execProcessFn';\nimport createDispatch from './createDispatch';\nimport createCancelled$ from './createCancelled$';\n\nvar debug = function debug()\n/* ...args */\n{};\n\nexport default function createLogicAction$(_ref) {\n  var _Observable$create;\n\n  var action = _ref.action,\n      logic = _ref.logic,\n      store = _ref.store,\n      deps = _ref.deps,\n      cancel$ = _ref.cancel$,\n      monitor$ = _ref.monitor$,\n      action$ = _ref.action$;\n  var getState = store.getState;\n  var name = logic.name,\n      processFn = logic.process,\n      _logic$processOptions = logic.processOptions,\n      dispatchReturn = _logic$processOptions.dispatchReturn,\n      dispatchMultiple = _logic$processOptions.dispatchMultiple,\n      successType = _logic$processOptions.successType,\n      failType = _logic$processOptions.failType;\n  var intercept = logic.validate || logic.transform; // aliases\n\n  debug('createLogicAction$', name, action);\n  monitor$.next({\n    action: action,\n    name: name,\n    op: 'begin'\n  }); // also in logicWrapper\n\n  var logicActionOps = [cancel$ ? takeUntil(cancel$) : null, // only takeUntil if cancel or latest\n  take(1)].filter(identityFn); // logicAction$ is used for the mw next(action) call\n\n  var logicAction$ = (_Observable$create = Observable.create(function (logicActionObs) {\n    // create notification subject for process which we dispose of\n    // when take(1) or when we are done dispatching\n    var _createCancelled$ = createCancelled$({\n      action: action,\n      cancel$: cancel$,\n      monitor$: monitor$,\n      logic: logic\n    }),\n        cancelled$ = _createCancelled$.cancelled$,\n        setInterceptComplete = _createCancelled$.setInterceptComplete;\n\n    var _createDispatch = createDispatch({\n      action: action,\n      cancel$: cancel$,\n      cancelled$: cancelled$,\n      logic: logic,\n      monitor$: monitor$,\n      store: store\n    }),\n        dispatch = _createDispatch.dispatch,\n        dispatch$ = _createDispatch.dispatch$,\n        done = _createDispatch.done; // passed into each execution phase hook as first argument\n\n\n    var ctx = {}; // for sharing data between hooks\n\n    var depObj = createDepObject({\n      deps: deps,\n      cancelled$: cancelled$,\n      ctx: ctx,\n      getState: getState,\n      action: action,\n      action$: action$\n    });\n\n    function shouldDispatch(act, useDispatch) {\n      if (!act) {\n        return false;\n      }\n\n      if (useDispatch === 'auto') {\n        // dispatch on diff type\n        return act.type !== action.type;\n      }\n\n      return useDispatch; // otherwise forced truthy/falsy\n    }\n\n    var AllowRejectNextDefaults = {\n      useDispatch: 'auto'\n    };\n\n    function applyAllowRejectNextDefaults(options) {\n      return _objectSpread({}, AllowRejectNextDefaults, options);\n    }\n\n    function allow(act) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AllowRejectNextDefaults;\n      handleNextOrDispatch(true, act, options);\n    }\n\n    function reject(act) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AllowRejectNextDefaults;\n      handleNextOrDispatch(false, act, options);\n    }\n\n    function handleNextOrDispatch(shouldProcess, act, options) {\n      var shouldProcessAndHasProcessFn = shouldProcess && processFn;\n\n      var _applyAllowRejectNext = applyAllowRejectNextDefaults(options),\n          useDispatch = _applyAllowRejectNext.useDispatch;\n\n      if (shouldDispatch(act, useDispatch)) {\n        monitor$.next({\n          action: action,\n          dispAction: act,\n          name: name,\n          shouldProcess: shouldProcess,\n          op: 'nextDisp'\n        });\n        setInterceptComplete();\n        dispatch(wrapActionForIntercept(act), {\n          allowMore: true\n        }); // will be completed later\n\n        logicActionObs.complete(); // dispatched action, so no next(act)\n      } else {\n        // normal next\n        if (act) {\n          monitor$.next({\n            action: action,\n            nextAction: act,\n            name: name,\n            shouldProcess: shouldProcess,\n            op: 'next'\n          });\n        } else {\n          // act is undefined, filtered\n          monitor$.next({\n            action: action,\n            name: name,\n            shouldProcess: shouldProcess,\n            op: 'filtered'\n          });\n          setInterceptComplete();\n        }\n\n        postIfDefinedOrComplete(act, logicActionObs);\n      } // unless rejected, we will process even if allow/next dispatched\n\n\n      if (shouldProcessAndHasProcessFn) {\n        // processing, was an accept\n        // if action provided is empty, give process orig\n        depObj.action = act || action;\n        execProcessFn({\n          depObj: depObj,\n          dispatch: dispatch,\n          done: done,\n          processFn: processFn,\n          dispatchReturn: dispatchReturn,\n          dispatch$: dispatch$,\n          name: name\n        });\n      } else {\n        // not processing, must have been a reject\n        dispatch$.complete();\n      }\n    }\n    /* post if defined, then complete */\n\n\n    function postIfDefinedOrComplete(act, act$) {\n      if (act) {\n        act$.next(act); // triggers call to middleware's next()\n      }\n\n      setInterceptComplete();\n      act$.complete();\n    } // start use of the action\n\n\n    function start() {\n      // normal intercept and processing\n      return intercept(depObj, allow, reject);\n    }\n\n    start();\n  })).pipe.apply(_Observable$create, _toConsumableArray(logicActionOps)); // take, takeUntil\n\n\n  return logicAction$;\n}","map":{"version":3,"sources":["/Users/aaronkaspar/Desktop/Mexiko/Modules/DAW/VisualStudio/Flight-main/node_modules/redux-logic/build-es/createLogicAction$.js"],"names":["_objectSpread","target","i","arguments","length","source","ownKeys","Object","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","obj","value","defineProperty","configurable","writable","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","prototype","toString","call","Array","from","isArray","arr2","isPromise","Observable","Subject","take","takeUntil","identityFn","wrapActionForIntercept","createDepObject","execProcessFn","createDispatch","createCancelled$","debug","createLogicAction$","_ref","_Observable$create","action","logic","store","deps","cancel$","monitor$","action$","getState","name","processFn","process","_logic$processOptions","processOptions","dispatchReturn","dispatchMultiple","successType","failType","intercept","validate","transform","next","op","logicActionOps","logicAction$","create","logicActionObs","_createCancelled$","cancelled$","setInterceptComplete","_createDispatch","dispatch","dispatch$","done","ctx","depObj","shouldDispatch","act","useDispatch","type","AllowRejectNextDefaults","applyAllowRejectNextDefaults","options","allow","undefined","handleNextOrDispatch","reject","shouldProcess","shouldProcessAndHasProcessFn","_applyAllowRejectNext","dispAction","allowMore","complete","nextAction","postIfDefinedOrComplete","act$","start","pipe","apply"],"mappings":"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","sourcesContent":["import \"core-js/modules/es6.array.iterator\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.function.name\";\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nimport isPromise from 'is-promise';\nimport { Observable, Subject } from 'rxjs';\nimport { take, takeUntil } from 'rxjs/operators';\nimport { identityFn, wrapActionForIntercept } from './utils';\nimport createDepObject from './createDepObject';\nimport execProcessFn from './execProcessFn';\nimport createDispatch from './createDispatch';\nimport createCancelled$ from './createCancelled$';\n\nvar debug = function debug()\n/* ...args */\n{};\n\nexport default function createLogicAction$(_ref) {\n  var _Observable$create;\n\n  var action = _ref.action,\n      logic = _ref.logic,\n      store = _ref.store,\n      deps = _ref.deps,\n      cancel$ = _ref.cancel$,\n      monitor$ = _ref.monitor$,\n      action$ = _ref.action$;\n  var getState = store.getState;\n  var name = logic.name,\n      processFn = logic.process,\n      _logic$processOptions = logic.processOptions,\n      dispatchReturn = _logic$processOptions.dispatchReturn,\n      dispatchMultiple = _logic$processOptions.dispatchMultiple,\n      successType = _logic$processOptions.successType,\n      failType = _logic$processOptions.failType;\n  var intercept = logic.validate || logic.transform; // aliases\n\n  debug('createLogicAction$', name, action);\n  monitor$.next({\n    action: action,\n    name: name,\n    op: 'begin'\n  }); // also in logicWrapper\n\n  var logicActionOps = [cancel$ ? takeUntil(cancel$) : null, // only takeUntil if cancel or latest\n  take(1)].filter(identityFn); // logicAction$ is used for the mw next(action) call\n\n  var logicAction$ = (_Observable$create = Observable.create(function (logicActionObs) {\n    // create notification subject for process which we dispose of\n    // when take(1) or when we are done dispatching\n    var _createCancelled$ = createCancelled$({\n      action: action,\n      cancel$: cancel$,\n      monitor$: monitor$,\n      logic: logic\n    }),\n        cancelled$ = _createCancelled$.cancelled$,\n        setInterceptComplete = _createCancelled$.setInterceptComplete;\n\n    var _createDispatch = createDispatch({\n      action: action,\n      cancel$: cancel$,\n      cancelled$: cancelled$,\n      logic: logic,\n      monitor$: monitor$,\n      store: store\n    }),\n        dispatch = _createDispatch.dispatch,\n        dispatch$ = _createDispatch.dispatch$,\n        done = _createDispatch.done; // passed into each execution phase hook as first argument\n\n\n    var ctx = {}; // for sharing data between hooks\n\n    var depObj = createDepObject({\n      deps: deps,\n      cancelled$: cancelled$,\n      ctx: ctx,\n      getState: getState,\n      action: action,\n      action$: action$\n    });\n\n    function shouldDispatch(act, useDispatch) {\n      if (!act) {\n        return false;\n      }\n\n      if (useDispatch === 'auto') {\n        // dispatch on diff type\n        return act.type !== action.type;\n      }\n\n      return useDispatch; // otherwise forced truthy/falsy\n    }\n\n    var AllowRejectNextDefaults = {\n      useDispatch: 'auto'\n    };\n\n    function applyAllowRejectNextDefaults(options) {\n      return _objectSpread({}, AllowRejectNextDefaults, options);\n    }\n\n    function allow(act) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AllowRejectNextDefaults;\n      handleNextOrDispatch(true, act, options);\n    }\n\n    function reject(act) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AllowRejectNextDefaults;\n      handleNextOrDispatch(false, act, options);\n    }\n\n    function handleNextOrDispatch(shouldProcess, act, options) {\n      var shouldProcessAndHasProcessFn = shouldProcess && processFn;\n\n      var _applyAllowRejectNext = applyAllowRejectNextDefaults(options),\n          useDispatch = _applyAllowRejectNext.useDispatch;\n\n      if (shouldDispatch(act, useDispatch)) {\n        monitor$.next({\n          action: action,\n          dispAction: act,\n          name: name,\n          shouldProcess: shouldProcess,\n          op: 'nextDisp'\n        });\n        setInterceptComplete();\n        dispatch(wrapActionForIntercept(act), {\n          allowMore: true\n        }); // will be completed later\n\n        logicActionObs.complete(); // dispatched action, so no next(act)\n      } else {\n        // normal next\n        if (act) {\n          monitor$.next({\n            action: action,\n            nextAction: act,\n            name: name,\n            shouldProcess: shouldProcess,\n            op: 'next'\n          });\n        } else {\n          // act is undefined, filtered\n          monitor$.next({\n            action: action,\n            name: name,\n            shouldProcess: shouldProcess,\n            op: 'filtered'\n          });\n          setInterceptComplete();\n        }\n\n        postIfDefinedOrComplete(act, logicActionObs);\n      } // unless rejected, we will process even if allow/next dispatched\n\n\n      if (shouldProcessAndHasProcessFn) {\n        // processing, was an accept\n        // if action provided is empty, give process orig\n        depObj.action = act || action;\n        execProcessFn({\n          depObj: depObj,\n          dispatch: dispatch,\n          done: done,\n          processFn: processFn,\n          dispatchReturn: dispatchReturn,\n          dispatch$: dispatch$,\n          name: name\n        });\n      } else {\n        // not processing, must have been a reject\n        dispatch$.complete();\n      }\n    }\n    /* post if defined, then complete */\n\n\n    function postIfDefinedOrComplete(act, act$) {\n      if (act) {\n        act$.next(act); // triggers call to middleware's next()\n      }\n\n      setInterceptComplete();\n      act$.complete();\n    } // start use of the action\n\n\n    function start() {\n      // normal intercept and processing\n      return intercept(depObj, allow, reject);\n    }\n\n    start();\n  })).pipe.apply(_Observable$create, _toConsumableArray(logicActionOps)); // take, takeUntil\n\n\n  return logicAction$;\n}"]},"metadata":{},"sourceType":"module"}