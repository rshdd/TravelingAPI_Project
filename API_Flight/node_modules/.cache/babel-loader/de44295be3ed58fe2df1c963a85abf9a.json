{"ast":null,"code":"import \"core-js/modules/es6.array.iterator\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.function.name\";\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nimport isPromise from 'is-promise';\nimport { Subject, from, of, throwError, isObservable } from 'rxjs';\nimport { defaultIfEmpty, tap, filter, map, mergeAll, takeUntil } from 'rxjs/operators';\nimport { identityFn, isInterceptAction, unwrapInterceptAction } from './utils';\nvar UNHANDLED_LOGIC_ERROR = 'UNHANDLED_LOGIC_ERROR'; // returns { dispatch, dispatch$, done };\n\nexport default function createDispatch(_ref) {\n  var action = _ref.action,\n      cancel$ = _ref.cancel$,\n      cancelled$ = _ref.cancelled$,\n      logic = _ref.logic,\n      monitor$ = _ref.monitor$,\n      store = _ref.store;\n  var name = logic.name,\n      _logic$processOptions = logic.processOptions,\n      dispatchMultiple = _logic$processOptions.dispatchMultiple,\n      successType = _logic$processOptions.successType,\n      failType = _logic$processOptions.failType;\n  var dispatchOps = [mergeAll(), cancel$ ? takeUntil(cancel$) : null, // only takeUntil if cancel or latest\n  tap(mapToActionAndDispatch, // next\n  mapErrorToActionAndDispatch // error\n  )].filter(identityFn);\n  var dispatch$ = new Subject();\n  dispatch$.pipe.apply(dispatch$, _toConsumableArray(dispatchOps)).subscribe({\n    error: function error()\n    /* err */\n    {\n      monitor$.next({\n        action: action,\n        name: name,\n        op: 'end'\n      }); // signalling complete here since error was dispatched\n      // accordingly, otherwise if we were to signal an error here\n      // then cancelled$ subscriptions would have to specifically\n      // handle error in subscribe otherwise it will throw. So\n      // it doesn't seem that it is worth it.\n\n      cancelled$.complete();\n      cancelled$.unsubscribe();\n    },\n    complete: function complete() {\n      monitor$.next({\n        action: action,\n        name: name,\n        op: 'end'\n      });\n      cancelled$.complete();\n      cancelled$.unsubscribe();\n    }\n  });\n\n  function storeDispatch(act) {\n    monitor$.next({\n      action: action,\n      dispAction: act,\n      op: 'dispatch'\n    });\n    return store.dispatch(act);\n  }\n\n  function mapToActionAndDispatch(actionOrValue) {\n    var act = isInterceptAction(actionOrValue) ? unwrapInterceptAction(actionOrValue) : successType ? mapToAction(successType, actionOrValue, false) : actionOrValue;\n\n    if (act) {\n      storeDispatch(act);\n    }\n  }\n  /* eslint-disable consistent-return */\n\n\n  function mapErrorToActionAndDispatch(actionOrValue) {\n    // action dispatched from intercept needs to be unwrapped and sent as is\n\n    /* istanbul ignore if  */\n    if (isInterceptAction(actionOrValue)) {\n      var interceptAction = unwrapInterceptAction(actionOrValue);\n      return storeDispatch(interceptAction);\n    }\n\n    if (failType) {\n      // we have a failType, if truthy result we will use it\n      var act = mapToAction(failType, actionOrValue, true);\n\n      if (act) {\n        return storeDispatch(act);\n      }\n\n      return; // falsey result from failType, no dispatch\n    } // no failType so must wrap values with no type\n\n\n    if (actionOrValue instanceof Error) {\n      var _act = actionOrValue.type ? actionOrValue : // has type\n      {\n        type: UNHANDLED_LOGIC_ERROR,\n        payload: actionOrValue,\n        error: true\n      };\n\n      return storeDispatch(_act);\n    } // dispatch objects or functions as is\n\n\n    var typeOfValue = _typeof(actionOrValue);\n\n    if (actionOrValue && ( // not null and is object | fn\n    typeOfValue === 'object' || typeOfValue === 'function')) {\n      return storeDispatch(actionOrValue);\n    } // wasn't an error, obj, or fn, so we will wrap in unhandled\n\n\n    storeDispatch({\n      type: UNHANDLED_LOGIC_ERROR,\n      payload: actionOrValue,\n      error: true\n    });\n  }\n  /* eslint-enable consistent-return */\n\n\n  function mapToAction(type, payload, err) {\n    if (typeof type === 'function') {\n      // action creator fn\n      return type(payload);\n    }\n\n    var act = {\n      type: type,\n      payload: payload\n    };\n\n    if (err) {\n      act.error = true;\n    }\n\n    return act;\n  } // allowMore is now deprecated in favor of variable process arity\n  // which sets processOptions.dispatchMultiple = true then\n  // expects done() cb to be called to end\n  // Might still be needed for internal use so keeping it for now\n\n\n  var DispatchDefaults = {\n    allowMore: false\n  };\n\n  function dispatch(act) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _applyDispatchDefault = applyDispatchDefaults(options),\n        allowMore = _applyDispatchDefault.allowMore;\n\n    if (typeof act !== 'undefined') {\n      // ignore empty action\n      dispatch$.next( // create obs for mergeAll\n      // eslint-disable-next-line no-nested-ternary\n      isObservable(act) ? act : isPromise(act) ? from(act) : act instanceof Error ? throwError(act) : of(act));\n    }\n\n    if (!(dispatchMultiple || allowMore)) {\n      dispatch$.complete();\n    }\n\n    return act;\n  }\n\n  function applyDispatchDefaults(options) {\n    return _objectSpread({}, DispatchDefaults, options);\n  }\n\n  function done() {\n    dispatch$.complete();\n  }\n\n  return {\n    dispatch: dispatch,\n    dispatch$: dispatch$,\n    done: done\n  };\n}","map":{"version":3,"sources":["/Users/aaronkaspar/Desktop/Mexiko/Modules/DAW/VisualStudio/Flight-main/node_modules/redux-logic/build-es/createDispatch.js"],"names":["_objectSpread","target","i","arguments","length","source","ownKeys","Object","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","obj","value","defineProperty","configurable","writable","_typeof","Symbol","iterator","constructor","prototype","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","toString","call","Array","from","isArray","arr2","isPromise","Subject","of","throwError","isObservable","defaultIfEmpty","tap","map","mergeAll","takeUntil","identityFn","isInterceptAction","unwrapInterceptAction","UNHANDLED_LOGIC_ERROR","createDispatch","_ref","action","cancel$","cancelled$","logic","monitor$","store","name","_logic$processOptions","processOptions","dispatchMultiple","successType","failType","dispatchOps","mapToActionAndDispatch","mapErrorToActionAndDispatch","dispatch$","pipe","apply","subscribe","error","next","op","complete","unsubscribe","storeDispatch","act","dispAction","dispatch","actionOrValue","mapToAction","interceptAction","Error","_act","type","payload","typeOfValue","err","DispatchDefaults","allowMore","options","undefined","_applyDispatchDefault","applyDispatchDefaults","done"],"mappings":"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","sourcesContent":["import \"core-js/modules/es6.array.iterator\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.function.name\";\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nimport isPromise from 'is-promise';\nimport { Subject, from, of, throwError, isObservable } from 'rxjs';\nimport { defaultIfEmpty, tap, filter, map, mergeAll, takeUntil } from 'rxjs/operators';\nimport { identityFn, isInterceptAction, unwrapInterceptAction } from './utils';\nvar UNHANDLED_LOGIC_ERROR = 'UNHANDLED_LOGIC_ERROR'; // returns { dispatch, dispatch$, done };\n\nexport default function createDispatch(_ref) {\n  var action = _ref.action,\n      cancel$ = _ref.cancel$,\n      cancelled$ = _ref.cancelled$,\n      logic = _ref.logic,\n      monitor$ = _ref.monitor$,\n      store = _ref.store;\n  var name = logic.name,\n      _logic$processOptions = logic.processOptions,\n      dispatchMultiple = _logic$processOptions.dispatchMultiple,\n      successType = _logic$processOptions.successType,\n      failType = _logic$processOptions.failType;\n  var dispatchOps = [mergeAll(), cancel$ ? takeUntil(cancel$) : null, // only takeUntil if cancel or latest\n  tap(mapToActionAndDispatch, // next\n  mapErrorToActionAndDispatch // error\n  )].filter(identityFn);\n  var dispatch$ = new Subject();\n  dispatch$.pipe.apply(dispatch$, _toConsumableArray(dispatchOps)).subscribe({\n    error: function error()\n    /* err */\n    {\n      monitor$.next({\n        action: action,\n        name: name,\n        op: 'end'\n      }); // signalling complete here since error was dispatched\n      // accordingly, otherwise if we were to signal an error here\n      // then cancelled$ subscriptions would have to specifically\n      // handle error in subscribe otherwise it will throw. So\n      // it doesn't seem that it is worth it.\n\n      cancelled$.complete();\n      cancelled$.unsubscribe();\n    },\n    complete: function complete() {\n      monitor$.next({\n        action: action,\n        name: name,\n        op: 'end'\n      });\n      cancelled$.complete();\n      cancelled$.unsubscribe();\n    }\n  });\n\n  function storeDispatch(act) {\n    monitor$.next({\n      action: action,\n      dispAction: act,\n      op: 'dispatch'\n    });\n    return store.dispatch(act);\n  }\n\n  function mapToActionAndDispatch(actionOrValue) {\n    var act = isInterceptAction(actionOrValue) ? unwrapInterceptAction(actionOrValue) : successType ? mapToAction(successType, actionOrValue, false) : actionOrValue;\n\n    if (act) {\n      storeDispatch(act);\n    }\n  }\n  /* eslint-disable consistent-return */\n\n\n  function mapErrorToActionAndDispatch(actionOrValue) {\n    // action dispatched from intercept needs to be unwrapped and sent as is\n\n    /* istanbul ignore if  */\n    if (isInterceptAction(actionOrValue)) {\n      var interceptAction = unwrapInterceptAction(actionOrValue);\n      return storeDispatch(interceptAction);\n    }\n\n    if (failType) {\n      // we have a failType, if truthy result we will use it\n      var act = mapToAction(failType, actionOrValue, true);\n\n      if (act) {\n        return storeDispatch(act);\n      }\n\n      return; // falsey result from failType, no dispatch\n    } // no failType so must wrap values with no type\n\n\n    if (actionOrValue instanceof Error) {\n      var _act = actionOrValue.type ? actionOrValue : // has type\n      {\n        type: UNHANDLED_LOGIC_ERROR,\n        payload: actionOrValue,\n        error: true\n      };\n\n      return storeDispatch(_act);\n    } // dispatch objects or functions as is\n\n\n    var typeOfValue = _typeof(actionOrValue);\n\n    if (actionOrValue && ( // not null and is object | fn\n    typeOfValue === 'object' || typeOfValue === 'function')) {\n      return storeDispatch(actionOrValue);\n    } // wasn't an error, obj, or fn, so we will wrap in unhandled\n\n\n    storeDispatch({\n      type: UNHANDLED_LOGIC_ERROR,\n      payload: actionOrValue,\n      error: true\n    });\n  }\n  /* eslint-enable consistent-return */\n\n\n  function mapToAction(type, payload, err) {\n    if (typeof type === 'function') {\n      // action creator fn\n      return type(payload);\n    }\n\n    var act = {\n      type: type,\n      payload: payload\n    };\n\n    if (err) {\n      act.error = true;\n    }\n\n    return act;\n  } // allowMore is now deprecated in favor of variable process arity\n  // which sets processOptions.dispatchMultiple = true then\n  // expects done() cb to be called to end\n  // Might still be needed for internal use so keeping it for now\n\n\n  var DispatchDefaults = {\n    allowMore: false\n  };\n\n  function dispatch(act) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _applyDispatchDefault = applyDispatchDefaults(options),\n        allowMore = _applyDispatchDefault.allowMore;\n\n    if (typeof act !== 'undefined') {\n      // ignore empty action\n      dispatch$.next( // create obs for mergeAll\n      // eslint-disable-next-line no-nested-ternary\n      isObservable(act) ? act : isPromise(act) ? from(act) : act instanceof Error ? throwError(act) : of(act));\n    }\n\n    if (!(dispatchMultiple || allowMore)) {\n      dispatch$.complete();\n    }\n\n    return act;\n  }\n\n  function applyDispatchDefaults(options) {\n    return _objectSpread({}, DispatchDefaults, options);\n  }\n\n  function done() {\n    dispatch$.complete();\n  }\n\n  return {\n    dispatch: dispatch,\n    dispatch$: dispatch$,\n    done: done\n  };\n}"]},"metadata":{},"sourceType":"module"}